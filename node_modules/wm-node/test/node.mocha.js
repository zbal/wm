var should = require('should');
var fs = require('fs');
var path = require('path');

require('./fixture');

var bonesTest = require('bones-test');
var server = bonesTest.server();

// Test config.
var config = server.plugin.config;
config.stash = path.resolve(require.resolve('./fixture'), '../');

// Test data.
var data = {
    ip: '8.8.8.8',
    public_key: 'aaa'
};

describe('Node Model', function() {
    // Model.
    bonesTest.testModel(server, 'Node');

    // CRUD.
    bonesTest.testModelCRUD(server, 'Node', data, {
        status: 'disabled'
    });
    bonesTest.testModelCRUDHTTP(server, 'Node', data, {
        status: 'disabled'
    });

    var model = server.plugin.models['Node'];

    // Validate.
    describe('Validate', function() {
        it('should return nothing with the right data', function(done) {
            should.not.exist(new model().validate(data));
            setTimeout(done, 1);
        });

        it('should return the error with missing IP', function(done) {
            var error = new model().validate({});
            error.should.be.a('object');
            error.should.have.property('message', 'IP is required');
            setTimeout(done, 1);
        });

        it('should return the error with invalid IP', function(done) {
            var error = new model().validate({
                ip: 'bad.ip.format.123'
            });
            error.should.be.a('object');
            error.should.have.property('message', 'Invalid IP format');
            setTimeout(done, 1);
        });
    });
    
    // custom functions
    describe('Custom functions', function() {
        var testModel = new model(data);
    
        it('should create the created_date and modified_date as equal', function(done) {
            testModel.setDefaults();
            testModel.get('created_date').should.be.a('number');
            testModel.save(null, {
                success: function(_model, res) {
                    _model.get('modified_date').should.equal(_model.get('created_date'));
                    setTimeout(done, 1);
                },
                error: function(_model, err) {
                    should.fail('Expecting no error');
                    setTimeout(done, 1);
                }
            });
        });
        
        it('should update the modified date on save', function(done) {
            testModel.save({status: 'disabled'}, {
                success: function(_model, res) {
                    _model.get('modified_date').should.be.a('number');
                    _model.get('modified_date').should.not.equal(_model.get('created_date'));
                    setTimeout(done, 1);
                },
                error: function(_model, err) {
                    should.fail('Expecting no error');
                    setTimeout(done, 1);
                }
            });
        });
        
        it('should set the geoip info', function(done) {
            testModel.setGeoSync({
                success: function() {
                    testModel.get('continent_code').should.be.a('string');
                    testModel.get('country_code').should.be.a('string');
                    setTimeout(done, 1);
                },
                error: function(err) {
                    should.fail('No error expected');
                    setTimeout(done, 1);
                }
            });
        });

        it('should save the modified GeoIP on save', function(done) {
            testModel.save({status: 'enabled'}, {
                success: function(_model, res) {
                    setTimeout(done, 1);
                },
                error: function(_model, err) {
                    should.fail('Expecting no error');
                    setTimeout(done, 1);
                }
            });
        });
        
        it('should destroy the testModel', function(done) {
            testModel.destroy({
                success: function() {
                    setTimeout(done, 1);
                },
                error: function() {
                    should.fail('Expecting no error');
                    setTimeout(done, 1);
                }
            });
        });
    });
});

describe('Nodes Collection', function() {
    var model = server.plugin.models['Node'];
    var collection = server.plugin.models['Nodes'];

    var node1 = new model();
    var node2 = new model();
    
    var data_node1 = {
        id: 'node1',
        ip: '1.1.1.1',
        public_key: 'aaa',
        continent_code: 'AS',
        country_code: 'CN',
        status: 'enabled'
    };
    var data_node2 = {
        id: 'node2',
        ip: '1.1.1.1',
        public_key: 'aaa',
        continent_code: 'AS',
        country_code: 'TW',
        status: 'disabled'
    };

    // Prepare collection
    describe('Collection creation', function() {
        it('should save the 1st node', function(done) {
            node1.save(data_node1, {
                success: function() {
                    setTimeout(done, 1);
                },
                error: function() {
                    should.fail('No error expected on node save');
                    setTimeout(done, 1);
                }
            });
        });
        it('should save the 2nd node', function(done) {
            node2.save(data_node2, {
                success: function() {
                    setTimeout(done, 1);
                },
                error: function() {
                    should.fail('No error expected on node save');
                    setTimeout(done, 1);
                }
            });
        });
    });
    
    // Filter
    describe('Nodes filtering', function() {
        var nodes = new collection();
        
        it('should return the entire collection', function(done) {
            nodes.fetch({
                success: function() {
                    nodes.length.should.equal(2);
                    setTimeout(done, 1);
                },
                error: function() {
                    should.fail('No error expected on collection fetch');
                    setTimeout(done, 1);
                }
            });
        });
        
        it('should return the entire collection (location)', function(done) {
            var collection = nodes.filterByLocations();
            collection.should.be.a('object');
            collection.should.have.property('add');
            collection.length.should.equal(2);
            var collection = nodes.filterByLocations({});
            collection.should.be.a('object');
            collection.should.have.property('add');
            collection.length.should.equal(2);
            var collection = nodes.filterByLocations([]);
            collection.should.be.a('object');
            collection.should.have.property('add');
            collection.length.should.equal(2);
            setTimeout(done, 1);
        });
        it('should return 0 node in the collection (location)', function(done) {
            var collection = nodes.filterByLocations({
                continent_code: 'NA'
            });
            
            collection.should.be.a('object');
            collection.should.have.property('add');
            collection.length.should.equal(0);
            setTimeout(done, 1);
        });
        it('should return 2 nodes in the collection (location)', function(done) {
            var collection = nodes.filterByLocations({
                continent_code: 'AS'
            });
            
            collection.should.be.a('object');
            collection.should.have.property('add');
            collection.length.should.equal(2);
            setTimeout(done, 1);
        });
        it('should return 1 node in the collection (location)', function(done) {
            var collection = nodes.filterByLocations({
                continent_code: 'AS',
                country_code: 'TW'
            });
            
            collection.should.be.a('object');
            collection.should.have.property('add');
            collection.length.should.equal(1);
            collection.models[0].get('country_code').should.equal('TW');
            setTimeout(done, 1);
        });
        it('should return 1 node in the collection (status)', function(done) {
            nodes.filterByStatus('enabled').length.should.equal(1);
            setTimeout(done, 1);
        });
        it('should return an empty list of nodes (bad status)', function(done) {
            nodes.filterByStatus(null).length.should.equal(0);
            nodes.filterByStatus('bad').length.should.equal(0);
            setTimeout(done, 1);
        });
    });

    describe('Cleanup', function() {
        it('should destroy the node1', function(done) {
            node1.destroy({
                success: function() {
                    setTimeout(done, 1);
                },
                error: function() {
                    should.fail('Expecting no error');
                    setTimeout(done, 1);
                }
            });
        });
        it('should destroy the node2', function(done) {
            node2.destroy({
                success: function() {
                    setTimeout(done, 1);
                },
                error: function() {
                    should.fail('Expecting no error');
                    setTimeout(done, 1);
                }
            });
        });
    });

    // Cleanup.
    describe('Remove the lorem stash', function() {
        it('should return no error', function(done) {
            fs.rmdir(path.resolve(config.stash, 'nodes'), function(err) {
                should.not.exist(err);
                setTimeout(done, 1);
            });
        });
    });
});

